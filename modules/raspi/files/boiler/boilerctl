#!/usr/bin/env python3
import math
import socket
import datetime
import time
import unittest

import pytz
import click
from gpiozero import Servo
from gpiozero.pins.pigpio import PiGPIOFactory



def send_metric(name, value):
    msg = f"boilerctl {name}={value}"
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.sendto(bytes(msg, "utf-8"), ("127.0.0.1", 8094))


def move(pos):
    pigpio_f = PiGPIOFactory()

    """
    Spec sheet[1] for the SF180M says:
        - full min: 0.5ms
        - middle  : 1.5ms
        - full max: 2.5ms

    [1] https://m.media-amazon.com/images/I/81+CuFyNFcL.pdf
    """
    servo = Servo(
        12,  # GPIO 12 (header pin 32, hardware PWM 0)
        initial_value=None,  # Otherwise this blasts the servo to 'mid' as it defaults to 0
        min_pulse_width=0.5/1000,
        max_pulse_width=2.5/1000,
        pin_factory=pigpio_f  # Using pigpio to allow hardware PWM, removing jitter
    )

    send_metric('desired_servo_position', pos)
    servo.value = pos
    time.sleep(5)
    servo.detach()


def scale_to_new_range(v, range_min, range_max, target_min, target_max):
    """
    Normalise/scale number to within different range:
    https://stats.stackexchange.com/a/281164
    """
    if range_max <= range_min:
        raise Exception("Invalid ranges: {range_min} -> {range_max}")
    if target_max <= target_min:
        raise Exception("Invalid ranges: {target_min} -> {target_max}")
    return ((v - range_min) / (range_max - range_min)) * (target_max - target_min) + target_min


def temp_to_servo_position(desired_temp_c, in_min=40, in_max=75, out_min=-1, out_max=1):
    """
    https://stackoverflow.com/a/43567380
    """
    assert desired_temp_c >= in_min
    assert desired_temp_c <= in_max
    return scale_to_new_range(desired_temp_c, in_min, in_max, out_min, out_max)


def return_temp_to_efficiency(return_temp):
    """
    Based on boiler efficiency curve here:
    https://www.heatgeek.com/condensing-boilers-efficiency/
    Two stages, power series down to the dew point, then linear
    """

    # Range of return temperatures (celcius) lower than the dew point
    return_range_ldp = (4, 54)
    efficiency_range_ldp = (87, 99.8)

    # Range of return temperatures (celcius) higher than the dew point
    return_range_adp = (55, 100)
    efficiency_range_adp = (85, 87)

    if return_temp < return_range_ldp[0]:
        raise Exception(f"Boiler return temp < {return_range_ldp[0]}C")
    elif return_temp <= return_range_ldp[1]:
        reversed_temp_with_ldp_range = return_range_ldp[1] - (return_temp - return_range_ldp[0])
        # TODO doesn't normalise or factor in the range of efficiency_range_ldp at all
        return round(81.2 * pow(reversed_temp_with_ldp_range, 0.0514), 2)
    elif return_temp <= return_range_adp[1]:
        reversed_temp_with_adp_range = return_range_adp[1] - (return_temp - return_range_adp[0])
        return round(
            scale_to_new_range(
                reversed_temp_with_adp_range,
                return_range_adp[0], return_range_adp[1],
                efficiency_range_adp[0], efficiency_range_adp[1])
                , 2)
    else:
        raise Exception(f"Boiler return temp > {return_range_adp[1]}C")


def move_dial_to_temp(desired_temp_c):
    send_metric('desired_temp_celcius', desired_temp_c)
    click.echo(f"Moving boiler dial to {desired_temp_c}C")
    move(temp_to_servo_position(desired_temp_c))


def in_low_temp_period_now():
    tz_lon = pytz.timezone('Europe/London')
    now = datetime.datetime.now(tz_lon)

    high_temp_periods = [
        ("03:30", "04:30"),
        ("14:00", "15:00")
    ]
    click.echo(f"Evaluating if current time of {now.time()} falls within high or low temp period")
    for start, end in high_temp_periods:
        start_h, start_m = start.split(':')
        end_h, end_m = end.split(':')

        start_t = datetime.time(int(start_h), int(start_m), tzinfo=tz_lon)
        end_t = datetime.time(int(end_h), int(end_m), tzinfo=tz_lon)

        if start_t <= now.time() <= end_t:
            click.echo(f" -> {start} ({start_t}) - {end} ({end_t}): matches this high temp period")
            return False
        else:
            click.echo(f" -> {start} ({start_t}) - {end} ({end_t}): no match")
    click.echo(f"-> choosing low temp period by default")
    return True


@click.group()
def cli():
    """
    TODO
    """


@click.command()
def calibrate():
    click.echo("Moving to min position. Turn boiler to min temperature, then attach servo horn in this position.")
    move(-1)


@cli.command()
def demo():
    move(-1)
    move(0)
    move(1)


@cli.command()
def autoset():
    if in_low_temp_period_now():
        send_metric('in_low_temp_period', 1)
        move_dial_to_temp(40)
    else:
        send_metric('in_low_temp_period', 0)
        move_dial_to_temp(70)

@cli.command()
def evaluate():
    """
    Designed to be run every minute (at least) by a cron job
    """
    pass


if __name__ == "__main__":
    # Dodgy version of unit testing within code :D
    assert temp_to_servo_position(40) == -1
    assert temp_to_servo_position(75) == 1
    assert temp_to_servo_position(57.5) == 0

    cli.add_command(calibrate)
    cli.add_command(autoset)
    cli.add_command(evaluate)
    cli.add_command(demo)
    cli()
