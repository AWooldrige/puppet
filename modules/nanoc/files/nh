#!/usr/bin/env python
from subprocess import check_call, CalledProcessError
import argparse
import yaml

def scall(cmd):
    print "Running {}".format(cmd)
    check_call(cmd, shell=True)

def make_prepare(path):
    scall("mkdir {}/SOURCES".format(path))

def make_clean(path):
    scall("rm -rf {0}/SOURCES {0}/output".format(path))

def make_build(path):
    make_clean(path)
    make_prepare(path)
    scall("(cd {} && nanoc compile)".format(path))

def make_install(path, domain):
    make_build(path)
    dest = "/var/nanoc-sites/{}".format(domain)
    tmpdest = "{}-tmp".format(dest)

    scall("sudo mkdir {}".format(tmpdest))
    scall("sudo cp -R {0}/output/* {1}".format(path, tmpdest))
    scall("sudo chown -R root:root {}".format(tmpdest))
    scall("sudo find {} -type d -print0 | sudo xargs -0 chmod 755".format(
        tmpdest))
    scall("sudo find {} -type f -print0 | sudo xargs -0 chmod 644".format(
        tmpdest))

    scall("sudo rm -rf {1} && sudo mv {0} {1}".format(tmpdest, dest))


def get_configuration(path):
    try:
        scall("ls {}/nanoc.yaml".format(path))
    except CalledProcessError:
        raise Exception (
            "'{}' doesn't seem to be a nanoc site path - can't find a " +
            "nanoc.yaml file.".format(path))

    with open("{}/nanoc.yaml".format(path)) as file:
        return yaml.safe_load(file)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("instruction",
                        choices=["build", "install", "clean"],
                        help="what the nanoc helper should do")
    parser.add_argument("-p", "--path", default=".",
                        help="path to compile with nanoc")
    args = parser.parse_args()
    path = args.path.rstrip('/')

    config = get_configuration(path)

    if args.instruction == "install":
        make_install(path, config["domain"])

    if args.instruction == "build":
        make_build(path)

    if args.instruction == "clean":
        make_clean(path)
